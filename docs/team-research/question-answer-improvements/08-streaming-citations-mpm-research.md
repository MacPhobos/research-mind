# Claude-MPM Internals: Streaming Output & Citation Generation

**Date**: 2026-02-07
**Researcher**: Research Agent (Task #4)
**Scope**: claude-mpm intermediate output capture for streaming progress, and citation generation pipeline analysis

---

## Executive Summary

This research examines two critical aspects of the claude-mpm execution pipeline as they relate to Research Mind's Q&A streaming experience:

1. **Streaming/Progress Output**: claude-mpm already produces rich intermediate output during execution (plain text initialization, JSON streaming events), and the Research Mind service already captures this via `asyncio.create_subprocess_exec` with stdout line-by-line parsing. The key gap is not the *ability* to capture intermediate output, but the *semantic richness* of Stage 1 events — they are largely opaque system initialization messages, not meaningful progress indicators.

2. **Citation Generation**: Citations are **not generated by claude-mpm itself**. The citation mechanism is entirely a Research Mind service-side responsibility — the sandbox `CLAUDE.md` instructs Claude to cite file paths, and the service's `extract_citations()` function parses these from the final answer text using regex. claude-mpm has no citation awareness, no citation formatting prompts, and no citation metadata in its output events.

---

## Item 1: Streaming/Progress Output from claude-mpm

### 1.1 Current Invocation Architecture

The Research Mind service invokes claude-mpm as a subprocess with this exact command structure (from `chat_service.py:581-595`):

```bash
claude-mpm run \
  --non-interactive \      # Oneshot mode
  --no-hooks \             # Skip hooks for speed
  --no-tickets \           # Skip ticket creation
  --launch-method subprocess \  # Required for output capture
  -i "<user_content>" \    # Input prompt
  -- \                     # Pass remaining to native claude CLI
  --output-format stream-json \  # Enable JSON streaming
  --verbose                # Include verbose system events
```

**Critical environment variables** set by the service (`chat_service.py:484-514`):
- `CLAUDE_MPM_USER_PWD=<workspace_path>` — Sets working directory
- `DISABLE_TELEMETRY=1` — Privacy
- `CLAUDE_MPM_SKIP_BACKGROUND_SERVICES=1` — Faster startup (skips agent/skill sync)

### 1.2 Output Stages and What's Currently Captured

The subprocess produces output in two distinct phases:

#### Phase A: Plain Text Initialization (claude-mpm startup)

Before JSON streaming begins, claude-mpm emits plain text to stdout:
- ASCII banner and version
- Agent deployment status
- Skill sync status
- "Starting Claude Code..." message
- Claude Code's own initialization text

These lines are captured by the service and classified as **Stage 1 (EXPANDABLE)** events with type `INIT_TEXT`. They appear in the UI's collapsible accordion section.

#### Phase B: JSON Streaming Events (Claude Code output)

Once Claude Code starts (after `--output-format stream-json` takes effect), structured JSON events flow:

| Event Type | Stage | Description |
|---|---|---|
| `system` (subtype: init) | EXPANDABLE | Tools, model, cwd initialization |
| `system` (subtype: hook_started/hook_response) | EXPANDABLE | Hook execution events |
| `stream_event` | EXPANDABLE | Token-by-token deltas (if `--include-partial-messages`) |
| `assistant` | PRIMARY | Complete assistant message with content blocks |
| `result` | PRIMARY | Final result with metadata (tokens, cost, timing) |

The service parses these via `classify_event()` (`chat_service.py:339-373`) and routes them appropriately.

### 1.3 The Progress Gap: What's Missing

The current architecture **already streams** intermediate output, but the semantic quality of Stage 1 content is poor for progress indication:

**What the UI currently sees in Stage 1:**
```
Starting Claude Code...
{"type":"system","subtype":"init","cwd":"/path/to/workspace","model":"claude-opus-4-6",...}
{"type":"system","subtype":"hook_started","hook":"user-prompt-submit-hook",...}
{"type":"system","subtype":"hook_response","hook":"user-prompt-submit-hook",...}
```

**What users want to see:**
- "Searching content for relevant information..."
- "Reading 3 files matching your query..."
- "Analyzing results..."
- "Composing answer..."

**Root cause**: Between the `system.init` event and the final `assistant`/`result` events, **there is a silence gap** of 10-60+ seconds where Claude Code is thinking and using tools. The `--output-format stream-json` mode does NOT emit progress events for tool use (Read, Grep, etc.) by default.

### 1.4 claude-mpm's Role in Subprocess Management

**Key finding**: claude-mpm does **NOT** persist as a daemon or middleware during execution. Its lifecycle is:

1. Initialize (sync, deploy, configure) — **~5-30 seconds overhead**
2. Build command with system prompt and agents
3. **Replace itself** with Claude Code via `os.execvpe()` (interactive mode) OR run as `subprocess.run()` (oneshot mode)

In the Research Mind service context (oneshot with `--launch-method subprocess`), the process chain is:

```
Research Mind Service
  └── asyncio.create_subprocess_exec("claude-mpm", ...)
        └── claude-mpm process (Python)
              └── subprocess.run(["claude", ...], capture_output=True)  ← OneshotSession._run_subprocess()
                    └── Claude Code process
                          └── Anthropic API calls
```

**Critical observation**: The `OneshotSession._run_subprocess()` method (`oneshot_session.py:169-202`) uses `subprocess.run(cmd, capture_output=True)`, which **blocks until completion** and buffers all output. This means:

- claude-mpm's oneshot mode does **NOT** stream output line-by-line
- It captures stdout/stderr in their entirety and returns them after process completion
- The `--output-format stream-json` flag on the inner `claude` command still works, but the JSON lines are buffered by claude-mpm's `subprocess.run()` until completion

**However**, the Research Mind service bypasses this buffering issue by reading stdout line-by-line from the **outer** `asyncio.create_subprocess_exec` process. The JSON streaming events from the inner Claude Code process flow through to the outer process's stdout because stdout is inherited through the process chain.

### 1.5 WebSocket/Socket.IO Monitoring System

claude-mpm has a built-in monitoring system using Socket.IO (`services/socketio_server.py`). When `--monitor` flag is used:

- `SocketIOClientProxy` connects to a Socket.IO server
- Events are broadcast: `session_started`, `claude_status_changed`, `claude_output`, `agent_delegated`, `session_ended`
- States tracked: `STARTING`, `RUNNING`, `ERROR`, `STOPPED`

This monitoring system is **not currently used** by the Research Mind service. It could theoretically provide progress signals, but:
- It requires running a Socket.IO server
- The events are coarse-grained (session-level, not query-level)
- It adds infrastructure complexity

### 1.6 EventBus System

claude-mpm has an internal `EventBus` (`services/event_bus/event_bus.py`) using `pyee.AsyncIOEventEmitter`:
- Singleton pattern with thread-safety
- Supports async handlers
- Event history tracking (last 100 events)
- Used primarily for hook event routing and monitoring integration

This EventBus is **internal to claude-mpm's process** and is **not accessible** from the Research Mind service since claude-mpm replaces itself with Claude Code via exec. Events published to the EventBus are only visible within the claude-mpm process before the exec handoff.

### 1.7 Available Configuration for Verbose Output

| Flag/Env | Effect | Relevance |
|---|---|---|
| `--verbose` | Include system events in stream-json output | Already used by service |
| `--output-format stream-json` | JSON event streaming | Already used by service |
| `--include-partial-messages` | Token-by-token streaming deltas | Would add `stream_event` tokens |
| `CLAUDE_MPM_SKIP_BACKGROUND_SERVICES=1` | Skip sync overhead | Already used by service |
| `--headless --resume` | Skip ALL background services | Faster but requires prior session |
| `--no-hooks` | Skip hook system | Already used by service |
| `--logging DEBUG` | Verbose logging to stderr | Would add debug info to stderr |

### 1.8 Feasibility Assessment: Streaming Progress Enhancement

**Option A: Token-by-Token Streaming (Low effort, Medium impact)**
- Add `--include-partial-messages` to the command
- Service receives `stream_event` JSON with token deltas
- Can show typing indicator and partial text as Claude composes
- **Limitation**: Still no visibility into tool use (search, read operations)

**Option B: Custom Progress Hook (Medium effort, High impact)**
- Create a Claude Code hook (post-tool-use) that emits progress JSON to stdout
- Hook would fire after each tool use (Read, Grep, WebSearch, etc.)
- Service parses hook events as additional Stage 1 content
- **Example progress events**:
  ```json
  {"type":"system","subtype":"hook_response","hook":"tool-progress","data":{"tool":"Read","file":"content-id/file.md"}}
  ```
- **Limitation**: hooks add overhead; requires `.claude/settings.local.json` deployment

**Option C: Synthetic Progress Messages (Low effort, Low-Medium impact)**
- Service generates progress messages based on elapsed time thresholds
- E.g., after 5s: "Analyzing content...", after 15s: "Composing detailed answer..."
- No claude-mpm changes needed — purely service-side
- **Limitation**: Not based on actual progress, just time-based heuristics

**Option D: Direct Claude Code Invocation (Medium effort, High impact)**
- Bypass claude-mpm entirely for Q&A queries
- Invoke `claude` directly with `--output-format stream-json --verbose`
- Pre-deploy instructions via `--system-prompt-file`
- Eliminates claude-mpm startup overhead entirely
- **Limitation**: Lose claude-mpm's agent/skill management (acceptable for Q&A)

### 1.9 Recommendation for Streaming Progress

**Short-term** (implement now): **Option C (Synthetic Progress)** — Zero claude-mpm changes, service-side only. Add time-based progress indicators during the silence gap.

**Medium-term** (next iteration): **Option A (Token Streaming)** — Add `--include-partial-messages` to show the answer as it's being composed, giving immediate visual feedback once Claude starts responding.

**Long-term** (architecture evolution): **Option D (Direct Invocation)** — For maximum performance, bypass claude-mpm for Q&A and invoke Claude Code directly. The existing `CLAUDE_MPM_SKIP_BACKGROUND_SERVICES=1` + `--no-hooks` + `--no-tickets` combination already minimizes claude-mpm's role to command assembly, which could be done statically.

---

## Item 2: Citation Generation in claude-mpm

### 2.1 Key Finding: Citations Are NOT Generated by claude-mpm

After thorough search of the entire claude-mpm codebase (`src/claude_mpm/`):
- **Zero** citation-related code in claude-mpm core
- **Zero** citation formatting in OUTPUT_STYLE.md
- **Zero** citation instructions in PM_INSTRUCTIONS.md
- **Zero** citation metadata in any event schema
- **Zero** citation references in the EventBus, monitoring, or response tracking systems

**Citations are entirely a Research Mind ecosystem responsibility**, managed through:
1. The sandbox `CLAUDE.md` template (instruction layer)
2. The service's `extract_citations()` function (extraction layer)
3. The `SourceCitation` Pydantic schema (transport layer)

### 2.2 The Citation Pipeline (End-to-End)

```
INSTRUCTION LAYER (what tells Claude to cite)
    |
    v
Session Sandbox: CLAUDE.md template
    - "Cite sources by including file paths for claims"
    - "e.g., According to `{content_id}/file.md`..."
    - "Include a Sources section at the end listing files referenced"
    |
    v
EXECUTION LAYER (what processes the query)
    |
    v
claude-mpm subprocess → Claude Code → Anthropic API
    - Claude reads CLAUDE.md instructions
    - Claude reads content files in sandbox
    - Claude generates answer WITH inline file path citations
    - Claude includes ## Sources section (per CLAUDE.md instructions)
    |
    v
EXTRACTION LAYER (what parses citations from the answer)
    |
    v
chat_service.py: extract_citations(stage2_content)
    - Regex: backtick-wrapped UUID/filename or 8-hex/filename patterns
    - Pattern: `((?:uuid_full|uuid_short)/[^`]+)`
    - Produces: list[SourceCitation] with file_path, content_id, title
    |
    v
TRANSPORT LAYER (how citations reach the UI)
    |
    v
ChatStreamCompleteEvent.metadata.sources: list[SourceCitation]
    - Attached to the "complete" SSE event
    - SourceCitation: {file_path, content_id, title}
```

### 2.3 Sandbox Directory Structure

Content is organized in the session workspace:

```
{content_sandbox_root}/{session_id}/
├── CLAUDE.md                              ← Research assistant instructions
├── .claude-mpm/
│   └── configuration.yaml                 ← Optimized config (sync disabled)
├── .claude/
│   └── skills/
│       ├── universal-data-json-data-handling/
│       ├── toolchains-ai-protocols-mcp/
│       └── universal-collaboration-writing-plans/
├── {content_id_1}/                        ← UUID directory
│   ├── file1.md
│   ├── file2.py
│   └── ...
├── {content_id_2}/                        ← UUID directory
│   ├── readme.md
│   └── ...
└── ...
```

The `content_id` directories are UUIDs assigned when content is added via the API (`content_service.py:82-83`). This UUID becomes the prefix in citation paths (e.g., `` `b1c2d3e4-f5g6.../file.md` ``).

### 2.4 Current Citation Extraction Logic

The `extract_citations()` function (`chat_service.py:402-436`):

```python
def extract_citations(content: str) -> list[SourceCitation]:
    uuid_short = r"[0-9a-f]{8}"
    uuid_full = r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"
    path_pattern = rf"`((?:{uuid_full}|{uuid_short})/[^`]+)`"

    for match in re.finditer(path_pattern, content):
        file_path = match.group(1)
        parts = file_path.split("/", 1)
        citations.append(SourceCitation(
            file_path=file_path,
            content_id=parts[0] if len(parts) > 1 else None,
            title=parts[1] if len(parts) > 1 else file_path,
        ))
    return citations
```

**Strengths:**
- Extracts inline citations from the answer body (not just the Sources section)
- Deduplicates by file_path
- Preserves first-occurrence order
- Handles both full UUID and 8-hex prefix patterns

**Weaknesses:**
- Only captures backtick-wrapped paths — misses citations in the `## Sources` section if not backtick-wrapped
- No URL citations (web search results are not captured)
- No verification that cited files actually exist in the sandbox
- `title` is just the filename portion — no source metadata (URL, description)
- No confidence/relevance scoring

### 2.5 claude-mpm's OUTPUT_STYLE.md: No Citation Instructions

The `OUTPUT_STYLE.md` file (`agents/OUTPUT_STYLE.md`) is the PM orchestration prompt. It contains:
- Mandatory delegation rules
- Communication standards
- Error handling protocol
- TodoWrite framework
- PM response format (JSON summary)

**It contains zero citation instructions.** This confirms that citation behavior is entirely controlled by the sandbox `CLAUDE.md` file deployed by the Research Mind service.

### 2.6 Where Source URLs Could Come From

Claude Code's tool use during a Q&A query may include:
1. **Read tool**: Reads files from the sandbox → produces file paths
2. **Grep tool**: Searches content in sandbox files → produces file paths with line numbers
3. **mcp-vector-search tools**: Semantic search across indexed content → produces file paths with relevance scores
4. **WebSearch/WebFetch** (if enabled): Web searches → produces URLs

Currently, none of this tool-use metadata is captured in the streaming output. The `--output-format stream-json` events include:
- `system.init` with tools list
- `system.hook_started`/`hook_response` for hooks
- `assistant` with the final text
- `result` with usage/cost metadata

**Tool use events are NOT included** in the stream-json output by default. The `--verbose` flag adds system events but not individual tool calls.

### 2.7 How Citations Could Include File Paths to Scraped Content

**Approach 1: Enhance CLAUDE.md instructions (Current pattern, improved)**

Update the sandbox `CLAUDE.md` to request structured citations:
```markdown
## Citation Format
When citing sources, use this exact format:
- Inline: `{content_id}/{filename}` in backticks
- Sources section: List each file with its content_id prefix
- For each citation, include the original source URL if available in the file metadata
```

**Approach 2: Content metadata file in sandbox**

Create a `_content_manifest.json` file in each session sandbox:
```json
{
  "content_id_1": {
    "source_url": "https://example.com/page",
    "title": "Example Page",
    "added_at": "2026-02-07T...",
    "type": "url_scrape"
  },
  "content_id_2": {
    "source_url": "https://github.com/user/repo",
    "title": "Repository",
    "type": "git_repo"
  }
}
```

Claude Code would read this manifest and include source URLs alongside file paths in its citations. The service's `extract_citations()` could then enrich `SourceCitation` objects with the original source URL by cross-referencing the manifest.

**Approach 3: Enrich citations post-extraction**

After `extract_citations()` parses file paths from the answer, cross-reference each `content_id` with the database `ContentItem` table to get the original source URL and metadata:

```python
# Pseudocode
for citation in citations:
    content_item = db.query(ContentItem).filter_by(content_id=citation.content_id).first()
    if content_item:
        citation.source_url = content_item.source_url
        citation.source_title = content_item.title
```

This requires no changes to claude-mpm or the sandbox — purely a service-side enrichment.

### 2.8 Feasibility Assessment: Citation Enhancement

| Enhancement | Effort | Impact | Dependencies |
|---|---|---|---|
| Enrich citations with DB metadata (Approach 3) | Low | High | Service-side only, no claude-mpm changes |
| Add content manifest to sandbox (Approach 2) | Medium | High | Service session creation + CLAUDE.md update |
| Improve CLAUDE.md citation instructions | Low | Medium | CLAUDE.md template update only |
| Capture tool-use events for citation tracking | High | Medium | Claude Code output format changes or custom hooks |
| Verify cited files exist in sandbox | Low | Medium | Service-side post-processing |

### 2.9 Recommendation for Citation Enhancement

**Immediate** (implement now):
1. **Enrich citations with DB metadata** (Approach 3) — Cross-reference `content_id` from extracted citations with `ContentItem` table to add `source_url` and `source_title` to `SourceCitation` objects
2. **Improve regex** — Also capture citations from the `## Sources` section that may not be backtick-wrapped

**Medium-term** (next iteration):
1. **Deploy content manifest** (Approach 2) — Create `_content_manifest.json` in sandbox at session creation time, so Claude has access to original source URLs
2. **Update CLAUDE.md template** — Request structured citation format with source URLs

**Long-term** (architecture evolution):
1. **Citation verification** — Validate that cited file paths actually exist in the sandbox before sending to UI
2. **Relevance scoring** — If mcp-vector-search is used, capture similarity scores and attach to citations

---

## Key File Reference

### claude-mpm Execution Files

| Component | File Path | Relevance |
|---|---|---|
| Oneshot session handler | `claude-mpm/src/claude_mpm/core/oneshot_session.py` | Subprocess execution for Q&A |
| Interactive session handler | `claude-mpm/src/claude_mpm/core/interactive_session.py` | Command building, exec launch |
| Run command | `claude-mpm/src/claude_mpm/cli/commands/run.py` | CLI entry point for sessions |
| Output style manager | `claude-mpm/src/claude_mpm/core/output_style_manager.py` | OUTPUT_STYLE.md deployment |
| OUTPUT_STYLE.md | `claude-mpm/src/claude_mpm/agents/OUTPUT_STYLE.md` | PM orchestration prompt (no citations) |
| EventBus | `claude-mpm/src/claude_mpm/services/event_bus/event_bus.py` | Internal event system (not externally accessible) |
| Socket.IO proxy | `claude-mpm/src/claude_mpm/services/socketio_server.py` | Optional monitoring (not used by service) |

### Research Mind Service Files

| Component | File Path | Relevance |
|---|---|---|
| Chat service (streaming) | `research-mind-service/app/services/chat_service.py` | Core streaming + citation extraction |
| Chat schemas | `research-mind-service/app/schemas/chat.py` | SourceCitation, metadata models |
| Session service | `research-mind-service/app/services/session_service.py` | Sandbox CLAUDE.md template |
| Path validator | `research-mind-service/app/sandbox/path_validator.py` | Sandbox security |
| API contract | `research-mind-service/docs/api-contract.md` | SourceCitation schema definition |

---

## Summary of Actionable Findings

### For Streaming Progress (Item 1)

1. **The streaming pipeline already works** — claude-mpm subprocess output flows to the service via line-by-line stdout parsing
2. **The silence gap** between system init and the final answer is the UX problem — no tool-use visibility
3. **`--include-partial-messages`** can provide token-by-token streaming for the answer composition phase
4. **Synthetic progress** (time-based) is the fastest path to improvement with zero dependencies
5. **Direct Claude Code invocation** (bypassing claude-mpm) would eliminate 5-30s startup overhead for Q&A

### For Citations (Item 2)

1. **claude-mpm has zero citation awareness** — all citation logic lives in the Research Mind service
2. **The CLAUDE.md template** in the sandbox is the sole instruction for citation behavior
3. **`extract_citations()`** works via regex on the final answer text — it's service-side post-processing
4. **Cross-referencing with ContentItem DB** is the easiest way to enrich citations with source URLs
5. **A content manifest JSON** in the sandbox would give Claude access to source metadata for richer citations
6. **No claude-mpm changes are needed** for citation improvements — all work is in the Research Mind service and sandbox setup

---

*Research completed. Both streaming and citation improvements can be achieved without modifying claude-mpm itself. The Research Mind service has full control over both the instruction layer (sandbox CLAUDE.md) and the extraction/enrichment layer (chat_service.py).*
